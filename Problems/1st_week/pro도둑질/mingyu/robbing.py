def solution(money):
    # 첫 번째 집을 터는 경우

    # dp테이블의 길이 초기화
    dp1 = [0]*len(money)

    # 첫 번째 집을  털 것이기 때문에 첫 번째 집의 값을 dp테이블에 추가
    dp1[0] = money[0]

    # 두 번째 집은 반드시 건너뛰나, 세 번째 집의 경우는 건너뛸 수도, 건너뛰지 않을 수도 있다.
    # {5, 3, 1, 2, 3}의 경우와 같이 첫 번째 집을 턴 후 두세번째 집을 건너뛰고 네 번째 집을 터는 경우가 있는데
    # 이 때 dp1[1]을 money[0], [1] 중 큰 값으로 설정해 두면 네 번째 집을 털게 될 때 dp1[i-2]의 값을 정확하게 받을 수 있다.
    dp1[1] = max(money[0], money[1])

    # dp1[0], [1]은 위에서 이미 설정했다. 그렇기 때문에 2부터 시작.
    # 첫 번째 집을 털기 때문에 마지막 집은 계산하지 않는다.(len(money)-1)
    for i in range(2, len(money)-1):

        # 이전 집을 터는게 나은지, 지금 집과 전전 집을 털어서 합친게 나은지 확인
        dp1[i] = max(dp1[i-1], money[i]+dp1[i-2])

    # 첫 번째 집을 털지 않는 경우

    # 해당 경우를 위한 dp테이블 초기화
    dp2 = [0]*len(money)

    # 첫 번째 집은 털지 않는다. 후에 마지막 집을 털 수 있기 때문에 dp2[0]은 최솟값인 0을 설정하여 계산에 간섭이 되지 않도록 설정
    dp2[0] = 0

    # 두 번째 집의 값을 우선 dp2[1]에 삽입
    dp2[1] = money[1]

    # 마찬가지로 [0], [1] 값은 이미 설정했기 때문에 2부터 시작
    # 마지막 집도 확인할 것이기 때문에 len(money)를 그대로 사용
    for i in range(2, len(money)):

        # 이전 집을 터는게 나은지, 지금 집과 전전 집을 털어서 합친게 나은지 확인
        dp2[i] = max(dp2[i-1], money[i]+dp2[i-2])

    # 두 경우의 수가 가진 최댓값을 비교하여 둘 중 더 큰 수를 리턴.
    return max(max(dp1), max(dp2))
